---
layout: post
title: c++ 数据共享与保护
date: 2019-11-14
tags: c++语言学习笔记
---

说明：本系列博客用来记录在学习c++语言时的笔记，便于与同学相互之间的学习讨论。（注：笔记会记录我学习过程中的重难点，不包括学习的所有知识点。）


## 1.标识符的作用域与可见性

### 1.1 作用域

作用域是一个标识符在程序正文中有效的区域。  

#### (1) 函数原型作用域

函数原型中的参数，其作用域始于"("，结束于")"。  
例如: `double area(double radius)`   

#### (2) 局部作用域

函数的形参、在块中声明的标识符；  
其作用域自声明处起，限于块中。  
例子：

```

void fun(int a) {
   int b = a;
   cin >> b;
   if (b > 0) {
     int c;

     ......
   }
}

```

#### (3) 类作用域

类可以被看成是一组有名成员的集合，类$X$的成员$m$具有类作用域，对$m$的访问方式有如下 3 种。  
(1) **如果在 $X$ 的成员函数中没有声明同名的局部作用域标识符，那么在该函数内可以直接访问成员 $m$**。也就是说 $m$ 在这样的函数中都起作用。  
(2) **通过表达式 $x.m$或者$x::m$。这正是程序中访问对象成员的最基本方法**。  
(3) **通过$ptr->m$这样的表达式，其中$ptr$为指向$X$类的一个对象的指针**。        

#### (4) 命名空间作用域 

举例:

```c++

//作用域实例
#include <iostream>

using namespace std;

int i;            //在全局命名空间中的全局变量

namespace Ns{
    int j;        //在 NS 命名空间中的全局变量
}

// 主函数
int main(){
    i = 5;        //为全局变量 i 赋值
    Ns::j=6;    //为全局变星]赋值
    {
        using namespace Ns; //使得在当前块中可以直接引用 Ns 命名空间的标识符
        int i;              //局部变量,局部作用域
        i = 7;
        cout<<"i="<<i<<endl; //输出 7
        cout<<"j="<<j<<endl; //输出 6

    }
    cout<<"i="<<i<<endl;//输出 5
    return 0;

}

```

### 1.2 可见性

从标识符引用的角度，来看标识符的有效范围，即标识符的可见性。程序运行到某一点，能够引用到的标识符，就是该处可见的标识符。  
作用域可见性的一般规则如下：  
1.标识符要声明在前，引用在后。  
2.在同一作用域中，不能声明同名的标识符。  
3.在没有互相包含关系的不同的作用域中声明的同名标识符，互不影响。  
4.如果在两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见。   

## 2.对象的生存期

对象(包括简单变量)都有诞生和消失的时刻。对象从诞生到结束的这段时间就是它的生存期。

### 2.1 静态生存期

如果对象的生存期与程序的运行期相同，则称它具有静态生存期。在命名空间作用域中声明的对象都是具有静态生存期的。如果要在函数内部的局部作用域中声明具有静态生存期的对象，则要使用关键字 **static** 。

### 2.2 动态生存期

在局部作用域中声明的具有动态生存期的对象，习惯上也称为局部生存期对象。**局部生存期对象诞生于声明点，结束于声明所在的块执行完毕之时**。

## 3. 类的静态成员

### 3.1 静态数据成员

### 3.2 静态函数成员

```

//具有静态数据和函数成员的Point类

#include<iostream>
using namespace std;

class Point{                                                   //Point类定义
public:                                                       //外部接口
    Point(int x=0,int y=0):x(x),y(y){                         //构造函数
        //在构造函数中对count累加，所有对象共同维护同一个count
        count++;
    }
    Point(Point &p){                                          //复制构造函数
        x=p.x;
        y=p.y;
        count++;
    }
    ~Point(){count--;}
    int getX(){return x;}
    int getY(){return y;}

    static void showCount(){                                 //静态函数成员
        cout<<" Object count="<<count<<endl;
    }
private:                                                     //私有数据成员
    int x,y;
    static int count;                                //静态数据成员声明，用于记录点的个数
};

int Point::count=0;                               //静态数据成员定义和初始化，使用类名限定

int main(){                                                //主函数
    Point::showCount();
    Point a(4,5);                               //定义对象a，其构造函数会使count增1
    cout<<"Point A: "<<a.getX()<<","<<a.getY();
    Point::showCount();                                    //输出对象个数

    Point b(a);                                  //定义对象b，其构造函数会使count增1
    cout<<"Point B: "<<b.getX()<<","<<b.getY();
    Point::showCount();                                     //输出对象个数

    return 0;
}

```

## 4. 类的友元

友元是C++提供的一种破坏数据封装和数据隐藏的机制。

通过将一个模块声明为另一个模块的友元，一个模块能够引用到另一个模块中本是被隐藏的信息。


### 4.1 友元函数

友元函数是在类声明中由关键字**friend**修饰说明的非成员函数，在它的函数体中能够通过对象名访问 private 和 protected 成员.

### 4.2 友元类

若一个类为另一个类的友元，则此类的所有成员都能访问对方类的私有成员。  
声明语法：将友元类名在另一个类中使用friend修饰说明。

```

class A {
    ...
    friend class B;
    ....
}；

```








<br>

转载请注明：[张鹏辉的博客](http://danielzph.github.io) >> [c++ 数据共享与保护](https://danielzph.github.io/2019/10/cpplearningprocess5/)
